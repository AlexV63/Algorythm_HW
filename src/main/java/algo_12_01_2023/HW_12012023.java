package algo_12_01_2023;

import java.lang.reflect.Array;

public class HW_12012023 {
//    Решить задачи через рекурсию, и далее оптимизовать алгоритм одним из методов динамического программирования:
//
//    На вершине лесенки, содержащей N ступенек, находится мячик, который начинает прыгать по ним вниз, к основанию.
//    Мячик может прыгнуть на следующую ступеньку, на ступеньку через одну или через 2.
//    (То есть, если мячик лежит на 8-ой ступеньке, то он может переместиться на 5-ую, 6-ую или 7-ую.)
//    Определить число всевозможных «маршрутов» мячика с вершины на землю.

    private static Integer jumpingWays(int n) {
        Integer[] score = new Integer[n + 1];
        score[0] = 0;
        score[1] = 1;
        score[2] = 2;
        score[3] = 4;
        if (n > 3) {
            for (int i = 4; i <= n; i++) {
                score[i] = score[i - 1] + score[i - 2] + score[i - 3];
            }
        }
        return score[n];
    }

    public static void main(String[] args) {
        int n = 8;
        System.out.println("Число всевозможных «маршрутов» мячика с вершины лесенки " + n
                + " на землю " + jumpingWays(n));
    }

//    Самый дешёвый путь
//    В каждой клетке прямоугольной таблицы N*M записано некоторое число.
//    Изначально игрок находится в левой верхней клетке.
//    За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено).
//    При проходе через клетку игрок платит определенную сумму, какое число записано в этой клетке.
//    Требуется найти минимальную стоимость пути, отдав которую игрок может попасть в правый нижний угол.







//    private static int payMoney() {
//        int n, m;
//        Array[][] table = new Array[n][m];
//
//        int[][] a;
//        for (int i = 0; i < n; i++)
//            for (int j = 0; j < m; j++)
//                table > a[i][j];
//
//        for (int i = 1; i < n; i++) {
//            a[i][0] += a[i - 1][0];
//            a[0][i] += a[0][i];
//        }
//        for (int i = 1; i < n; i++) {
//            for (int j = 1; j < m; j++) {
//                int a1 = a[i - 1][j];
//                int a2 = a[i][j - 1];
//                a[i][j] += std::min(a1, a2);
//            }
//        }
//         << a[n - 1][m - 1];
//    }
}






